{
"version":3,
"file":"browser.js",
"sourceRoot":"file:///",
"sources":["/home/fullofcaffeine/workspace/code/haxe-debugger-source-map-experiment/Main.hx","/home/fullofcaffeine/haxe/versions/4.0.0-rc.2/std/js/Boot.hx"],
"sourcesContent":["@:forward(push, pop)\nabstract MyArray<S>(Array<S>) {\n  public function new() {\n    // Adding a breakpoint below will not work, the js debugger will never stop here...\n    this = [];\n  }\n}\n\nclass Main {\n  static public function main() {\n    // The following is NOT needed for the debugging source-map support but only for runtime\n    // source-map support, wich is a nice way to get stacktraces that point to the Haxe source\n    // instead of the js file.\n    // Source: https://stackoverflow.com/questions/33778714/haxe-nodejs-debugging-source-mapping\n\n    #if !clientjs\n    js.Lib.require('source-map-support').install();\n    haxe.CallStack.wrapCallSite = js.Lib.require('source-map-support').wrapCallSite;\n    #end\n    // When using vscode, adding breakpoints here will work as long as `-debug` is added to the build.hxml.\n    // the debugger will stop in the Haxe code and not the js code (using the source-maps).\n\n    // MyArray won't be inspectable when debugging, because it only exists during compile-time\n    var myArray = new MyArray();\n    myArray.push(12);\n    myArray.pop();\n\n    // This tests runtime source-mapping\n    throw 'test';\n  }\n}\n","/*\n * Copyright (C)2005-2019 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nimport js.Syntax; // import it here so it's always available in the compiler\n\nprivate class HaxeError extends js.Error {\n\tvar val:Dynamic;\n\n\t@:pure\n\tpublic function new(val:Dynamic) {\n\t\tsuper();\n\t\tthis.val = val;\n\t\tif ((cast js.Error).captureStackTrace) (cast js.Error).captureStackTrace(this, HaxeError);\n\t}\n\n\tpublic static function wrap(val:Dynamic):js.Error {\n\t\treturn if (js.Syntax.instanceof(val, js.Error)) val else new HaxeError(val);\n\t}\n\n\tstatic function __init__() {\n\t\tjs.Object.defineProperty((cast HaxeError).prototype, \"message\", {get: () -> (cast String)(js.Lib.nativeThis.val)});\n\t}\n}\n\n@:dox(hide)\nclass Boot {\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse {\n\t\t\tvar cl = untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t\t\tif (cl != null)\n\t\t\t\treturn cl;\n\t\t\tvar name = __nativeClassName(o);\n\t\t\tif (name != null)\n\t\t\t\treturn __resolveNativeClass(name);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@:ifFeature(\"has_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = js.Syntax.typeof(o);\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\t#if !js_enums_as_arrays\n\t\t\t\tif (o.__enum__) {\n\t\t\t\t\tvar e = $hxEnums[o.__enum__];\n\t\t\t\t\tvar n = e.__constructs__[o._hx_index];\n\t\t\t\t\tvar con = e[n];\n\t\t\t\t\tif (con.__params__) {\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\treturn n + \"(\" +\n\t\t\t\t\t\t\t[for (p in (con.__params__:Array<String>)) __string_rec(o[p],s)].join(\",\") + \")\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#end\n\t\t\t\tif( js.Syntax.instanceof(o, Array) ) {\n\t\t\t\t\t#if js_enums_as_arrays\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\t#end\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") && js.Syntax.typeof(tostr) == \"function\" ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tif( js.Object.prototype.hasOwnProperty.call(cc, \"__interfaces__\") ) {\n\t\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") @:pure private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn js.Syntax.typeof(o) == \"number\" && js.Syntax.strictEq(o | 0, o);\n\t\tcase Float:\n\t\t\treturn js.Syntax.typeof(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn js.Syntax.typeof(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn js.Syntax.typeof(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn js.Syntax.instanceof(o, Array) #if js_enums_as_arrays && o.__enum__ == null #end;\n\t\tcase Dynamic:\n\t\t\treturn o != null;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class or a native JS object\n\t\t\t\tif( js.Syntax.typeof(cl) == \"function\" ) {\n\t\t\t\t\tif( js.Syntax.instanceof(o, cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if ( js.Syntax.typeof(cl) == \"object\" && __isNativeObj(cl) ) {\n\t\t\t\t\tif( js.Syntax.instanceof(o, cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\t#if js_enums_as_arrays\n\t\t\treturn o.__enum__ == cl;\n\t\t\t#else\n\t\t\treturn if (o.__enum__ != null) (untyped $hxEnums[o.__enum__]) == cl else false;\n\t\t\t#end\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (o == null || __instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n\tstatic var __toStr:js.Function;\n\tstatic function __init__() {\n\t\tBoot.__toStr = (cast {}).toString;\n\t}\n\n\t// get native JS [[Class]]\n\tstatic function __nativeClassName(o:Dynamic):String {\n\t\tvar name:String = __toStr.call(o).slice(8, -1);\n\t\t// exclude general Object and Function\n\t\t// also exclude Math and JSON, because instanceof cannot be called on them\n\t\tif (name == \"Object\" || name == \"Function\" || name == \"Math\" || name == \"JSON\")\n\t\t\treturn null;\n\t\treturn name;\n\t}\n\n\t// check for usable native JS object\n\tstatic function __isNativeObj(o:Dynamic):Bool {\n\t\treturn __nativeClassName(o) != null;\n\t}\n\n\t// resolve native JS class in the global scope:\n\tstatic function __resolveNativeClass(name:String) {\n\t\treturn js.Lib.global[cast name];\n\t}\n\n}\n"],
"names":[],
"mappings":";;;;;;;;;8BAEE;AAAA,aAES;AAFT;AAAA;;YAOA,WAA8B;AAAA,CAc5B,cAAc;AAdc,CAe5B,aAAa;AAfe,CAgB5B;AAhB4B,CAmB5B,MAAO;AAnBqB;0BCoB/B,cAAiC;AAAA,CAChC;AADgC,CAEhC,WAAW;AAFqB,CAGhC,EAAI,CAAM,yBAA6B;AAAA,EAAM,wBAA4B,KAAM;AAAxC;AAHP;;;;AAWhC,sBAAyB,AAAM,8BAAsB,UAAW,QAAM,WAAM;AAAA,QAAM,OAAQ;AAAd;;;;"
}